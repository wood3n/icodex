---
title: 模块化语法
---

## 概述

## 什么是模块

模块可以简单理解为一个文件或者一段程序，包括 js，css，img 等都可以称为一个模块，或者一个 JS 方法等。

前端模块化语法主要分为以下几种：

- AMD：ES6 之前的，大概 2013 年提出的异步加载模块的规范；最初由[`requirejs`](https://requirejs.org/)实现
- CommonJS：为 Node.js 服务器创建的模块系统；最早于 2009 年提出；
- UMD：通用模块语法，兼容 AMD 和 CommonJS；
- ESM：ES Modules，ES6 提出的模块化语法，主要在浏览器中使用，NodeJS 内部未来也会支持；
- SystemJS：SystemJS 是一个可运行于浏览器端的模块加载器，是一个 polifill，可以让我们在浏览器上直接使用 ES 模块等先进语法，而不用管浏览器是否支持该语法。

## 为什么需要模块化

- 模块化的作用域限制标识符的解析范围，避免不同程序之间的相互影响；
- 拆分模块，增强代码可复用性和可维护性，提高开发效率；
- 前端页面根据模块之前的关联关系按需加载资源，提高页面渲染速度，优化用户体验；

## AMD

[AMD](<https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)>) 全名 Asynchronous Module Definition，也就是异步模块规范。它可以使模块和模块的依赖被异步加载，因此用于浏览器环境。

### define

AMD 通过`define`来定义模块，通过`require`加载模块，不过`require`区别于 CommonJS 的`require`语法，因为它是异步地加载动态的依赖。

> `define(id?, dependencies?, factory)`

`define`接收三个参数：

- `id`：表示模块的名称，由一个或多个单词以正斜杠为分隔符拼接成的字符串
- `dependencies`：该模块内部所依赖的模块名称的数组
- `factory`：模块初始化要执行的函数或对象，如果是函数会接收依赖数组中的位置顺序作为参数，同时返回一个值（对象，函数，或任意强制类型转换为 true 的值）作为模块的输出；如果是对象，此对象就是模块的输出值

```javascript
// 定义匿名模块，使用了 alpha 模块，并输出一个对象
define(['alpha'], function(alpha) {
  return {
    verb: function() {
      return alpha.verb() + 2;
    },
  };
});
```

### require

模块方法内部可以通过`require`加载模块，`require`可以做到同步和异步加载模块。

> `require(string)`

**同步**地返回模块 ID 所代表的模块。

```javascript
define(function(require) {
  var a = require('a');
});
```

> `require(Array, Function)`

**异步**加载模块并执行回调。参数 Array 是一个由模块 ID 组成的数组。当模块 ID 所代表的模块加载完成且可用时，回调函数 Function 才开始执行，并且只被执行一次。各个模块按照依赖数组中的位置顺序以参数的形式传入到 Function 里。

```javascript
define(function(require) {
  require(['a', 'b'], function(a, b) {});
});
```

## CommonJS

[CommonJS 规范](http://nodejs.cn/api/modules.html#modules_the_module_object)的目的是在浏览器以外的环境使用模块系统，用于 NodeJS 中来**同步**加载**本地**模块文件。CommonJS 规范特点如下：

- 建立在本地文件目录的基础上，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见；

- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；
- 模块按照代码中出现的顺序同步加载，遇到 `require(id)` 时会停下来等待，直到新的模块加载完成之后再继续执行接下去的代码；虽然是同步串行加载，但是因为只是读取本地硬盘上的文件，不需要网络请求，所以此过程非常迅速；
- 支持动态导入
-

### \_\_dirname

`__dirname`在模块内部使用时，代表当前模块的目录名，是绝对路径

### \_\_filename

`__filename`表示当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。

### module.exports

> `module.exports = {}`

在每个模块中都有一个[`module` 对象](http://nodejs.cn/api/modules.html#modules_the_module_object)是对代表当前模块的对象的引用，其具有`id`，`path`，`parent`等属性，同时还具有一个`exports`属性，作为对外输出变量的接口，需要将对象或值赋值给 `module.exports`来导出。由于是赋值的机制，所以只支持导出一个值。

`module.exports`可以在文件级作用域内简写成`exports`，但是需要注意的是`exports`仅作为`module.exports`指向对象引用的拷贝，如果将新值分配给 `exports`，则它就不再绑定到 `module.exports`

```javascript
module.exports.hello = true; // 从模块的 require 中导出
exports.hello = false; // module.exports.hello的值也会变成false
exports = { hello: false }; // 未导出，仅在模块中可用
```

### require

> `require(id)`

`require`用于访问指定模块的 `module.exports`对象，来导入`js`、`JSON`模块。

id：模块名称或路径；根据 id 的不同格式，`require`命令会去不同路径寻找模块文件：

1. 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件；
2. 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件，该路径将根据 [`__dirname`](http://nodejs.cn/api/modules.html#modules_dirname)（如果有定义）命名的目录或当前工作目录进行解析；
3. 如果没有前导 `'/'`、`'./'` 或 `'../'` 来指示文件，则该模块必须是核心模块或从 `node_modules` 文件夹加载；从 `node_modules` 查找时会从当前指定的文件目录开始，一层一层往上，直到到达文件系统的根目录；

4. 如果找不到确切的文件名，Node.js 将尝试加载所需的文件名，并添加扩展名：`.js`、`.json`，最后是 `.node`。

`require`支持动态导入，也就是可以在语句块中使用，见[javascript - Loading Node.js modules dynamically based on route - Stack Overflow](https://stackoverflow.com/questions/10914751/loading-node-js-modules-dynamically-based-on-route)。

```javascript
if (true) {
  require('xxx');
}
```

`require`加载的模块是对`module.exports`导出的值的拷贝，所以模块之间使用不会存在影响。

### 作用域

NodeJS 会对使用`require`加载的模块使用一个函数进行包装，这样模块内部的变量就会被限制在函数作用域中

```javascript
(function(exports, require, module, __filename, __dirname) {
  // 模块代码实际存在于此处
});
```

### 缓存

`require`解析模块路径然后查找文件的过程比较耗时，NodeJS 会对使用`require`加载的模块按照模块的绝对路径和`module`对象进行缓存，这样后续解析相同的模块路径直接从缓存读取，以提高文件模块查找效率，同时还可以解决循环引用的问题。

可以使用`require.cache`查看缓存的`module`对象，类似于下面的数据结构

```javascript
{
    '/Users/evan/Desktop/demo/main.js':
       Module {
         id: '.',
         exports: {},
         parent: null,
         filename: '/Users/evan/Desktop/demo/main.js',
         loaded: false,
         children: [ [Object] ],
         paths:
          [ '/Users/evan/Desktop/demo/node_modules',
            '/Users/evan/Desktop/node_modules',
            '/Users/evan/node_modules',
            '/Users/node_modules',
            '/node_modules'
          ]
       },
  '/Users/evan/Desktop/demo/a.js':
       Module {
         id: '/Users/evan/Desktop/demo/a.js',
         exports: { foo: 1 },
         parent:
          Module {
            id: '.',
            exports: {},
            parent: null,
            filename: '/Users/evan/Desktop/demo/main.js',
            loaded: false,
            children: [Array],
            paths: [Array] },
         filename: '/Users/evan/Desktop/demo/a.js',
         loaded: true,
         children: [],
         paths:
          [ '/Users/evan/Desktop/demo/node_modules',
            '/Users/evan/Desktop/node_modules',
            '/Users/evan/node_modules',
            '/Users/node_modules',
            '/node_modules'
          ]
       }
}
```

## UMD

[UMD](https://github.com/umdjs/umd)，全名 Universal Module Definition，即全局模块规范。UMD 的设计就是为了兼容 AMD 和 CommonJS 的实现。

经过 UMD 打包的模块代码会使用以下函数封装，以兼容 NodeJS，AMD 还有浏览器环境

```javascript
(function(root, factory) {
  // 判断 AMD
  if (typeof define === 'function' && define.amd) {
    define(['b'], factory);
    // 判断 Nodejs
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('b'));
  } else {
    // 浏览器
    root.returnExports = factory(root.b);
  }
})(typeof self !== 'undefined' ? self : this, function(b) {
  return {};
});
```

## ES Modules
